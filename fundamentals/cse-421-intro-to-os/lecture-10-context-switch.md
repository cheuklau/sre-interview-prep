# Lecture 10

## CPU Limitations: Number

- Historically we were limited to one core i.e., one processor. Why?
    * Expensive and complex
- Recently we have many. Why?
    * At some point it was no longer feasible to make a single core faster e.g., due to heat
    * Therefore, we started adding more cores
- In general, there are fewer cores than tasks to be run
- How does the CPU compare to other parts of the system e.g., memory, disk, etc
    * CPU is way faster
    * Faster than memory - usually addressed on the processor through out-of-order execution
    * Way faster than disk - addressed by the OS
    * Way faster than you - partially addressed by OS
- Human can withstand 15ms of lag which is equivalent ot 15,000,000 CPU clock cycles for 1GHz processor

## Birth of the OS

- OS emerged partly to hide delays caused by slow devices to keep processor active
- Hiding processor delays requires only cooperative scheduling
    * Threads only stop running when they require a long-latency operation

## Supporting Multiple Interactive Users

- Support multiple users requires the notion that multiple tasks are running simulataneously or concurrently, either:
    1. One task per user for multiple users
    2. Multiple tasks for a single user
    3. Multiple tasks for multiple users

## The Illusion of Concurrency

- How is this accomplished?
    * Processors rapidly switches between tasks creating the notion of concurrency
    * We refer to these transitions as context switches

## Implementing Context Switching

- How does the OS get control?
    1. Hardware interrupts
    2. Software interrupts
    3. Software exceptions
- But what if these things don't happen?
- Timer interrupts generated by a timer device ensure that the OS regains control of the system at regular intervals
- Timer interrupts are the basis of preemptive scheduling - OS doesn't wait for the thread to stop running, instead it preempts it
- Rest of interrupt handling is unchanged
- Timer interrupts means that a running thread may be stopped at any time
- When the thread restarts we want it to appear that nothing has changed i.e., that the execution was not interrupted
    * Other parts of the system might have changed, but the CPU state should be identical
- How do we do this?

## Saving Thread State

- What does thread state consist of?
    * Registers
    * Stacks
- We rely on memory protection to keep the stack unchanged until we restart the thread
- Saving thread is the first thing that happens when the interrupt service routine (ISR) is triggered. Why?
    * Saved state is sometimes refer to as a trap frame.

## Context Switching

- Threads switch to a separate kernel stack when executing in the kernel. Why?
    * The kernel doesn't trust (or want to pollute) the user thread's stack
